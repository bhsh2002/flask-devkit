# 9. ضمان سلامة البيانات: المُزين `@unit_of_work`

في أي تطبيق يتعامل مع قاعدة بيانات، من الشائع أن تحتاج إلى تنفيذ عدة عمليات كتابة (create, update, delete) معًا كجزء من عملية منطقية واحدة. على سبيل المثال، عند إنشاء طلب جديد، قد تحتاج إلى إنشاء سجل الطلب وتحديث مخزون المنتجات في نفس الوقت.

ماذا يحدث إذا نجحت العملية الأولى (إنشاء الطلب) وفشلت الثانية (تحديث المخزون)؟ ستكون قاعدة بياناتك في حالة غير متسقة.

هنا يأتي دور نمط "وحدة العمل" (Unit of Work).

## ما هو نمط وحدة العمل؟

وحدة العمل هي قائمة من العمليات التي يجب أن تنجح جميعها أو تفشل جميعها كوحدة واحدة. في سياق قاعدة البيانات، يُعرف هذا باسم **المعاملة (Transaction)**.

المُزين `@unit_of_work` في `Flask-DevKit` هو أداة بسيطة وقوية لتطبيق هذا النمط.

## كيف يعمل؟

عندما تقوم بتزيين دالة ما بـ `@unit_of_work`، فإنه يقوم تلقائيًا بالآتي:

1.  يبدأ معاملة قاعدة بيانات (transaction).
2.  ينفذ الكود الموجود داخل الدالة المزينة.
3.  **إذا اكتملت الدالة بنجاح** دون أي أخطاء (exceptions)، فإنه يقوم بتنفيذ `db.session.commit()`. يتم حفظ جميع التغييرات بشكل دائم في قاعدة البيانات.
4.  **إذا حدث أي خطأ** داخل الدالة، فإنه يقوم بتنفيذ `db.session.rollback()`. يتم التراجع عن **جميع** التغييرات التي حدثت داخل المعاملة، وتعود قاعدة البيانات إلى حالتها الأصلية قبل بدء الدالة.

## أين يتم استخدامه؟

يتم استخدام هذا المُزين عادةً على **دوال المسارات (route functions)** التي تؤدي إلى عمليات كتابة في قاعدة البيانات.

**ملاحظة:** تقوم دالة `register_crud_routes` المدمجة بالفعل بتطبيق هذا المُزين تلقائيًا على نقاط النهاية `create`, `update`, `delete`, `restore`, و `force_delete`. لذلك، تحتاج فقط إلى استخدامه في نقاط النهاية المخصصة التي تقوم بإنشائها.

### مثال: عملية تحويل بنكي

لنفترض أن لدينا دالة مخصصة لتحويل الأموال بين حسابين. يجب أن تتضمن العملية خطوتين: سحب من حساب وإيداع في حساب آخر. يجب أن تنجح كلتاهما أو تفشلا معًا.

```python
from flask_devkit.core.unit_of_work import unit_of_work
from flask_devkit.helpers.routing import register_custom_route

# ... (داخل دالة إنشاء الـ blueprint)

@bp.post("/accounts/transfer")
@bp.input(TransferSchema)
@bp.output(MessageSchema)
@unit_of_work  # <-- هنا يتم تطبيق وحدة العمل
def transfer_funds(json_data):
    """
    تحويل الأموال بين حسابين.
    """
    account_service = g.devkit.get_service("account")

    # الخطوة 1: سحب من الحساب المصدر
    account_service.debit(
        account_id=json_data["from_account"],
        amount=json_data["amount"]
    )

    # الخطوة 2: إيداع في الحساب الهدف
    # إذا فشلت هذه الخطوة لأي سبب (e.g., الحساب غير موجود),
    # سيقوم @unit_of_work بالتراجع عن عملية السحب تلقائيًا.
    account_service.credit(
        account_id=json_data["to_account"],
        amount=json_data["amount"]
    )

    return {"message": "Transfer successful"}

```

بفضل `@unit_of_work`، يمكنك كتابة منطق عملك بثقة، مع العلم أن سلامة بياناتك مضمونة. لن تضطر أبدًا إلى كتابة `try...except...commit...rollback` يدويًا مرة أخرى في طبقة المسارات.
